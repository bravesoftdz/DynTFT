program DynTFTExample;

uses
  DynTFTMessageBox;
  
const HEAP_START: DWord = $A0000FDC;  //make sure this is a valid address and is DWord aligned !
const HEAP_SIZE: DWord = 20000;   //Make sure enough memory is allocated. See the desktop application (simulator) for guidance.

//Parts of the code come from mikromedia example. Other parts are generated by mikroPascal.

// TFT module connections
var TFT_BLED_Direction : sbit  at TRISC2_bit;
    TFT_BLED : sbit  at LATC2_bit;
    TFT_CS_Direction : sbit  at TRISF12_bit;
    TFT_CS : sbit  at LATF12_bit;
    TFT_DataPort_Direction : word  at TRISE;
    TFT_DataPort : word  at LATE;
    TFT_RD_Direction : sbit  at TRISD5_bit;
    TFT_RD : sbit  at LATD5_bit;
    TFT_RS_Direction : sbit  at TRISB15_bit;
    TFT_RS : sbit  at LATB15_bit;
    TFT_RST_Direction : sbit  at TRISC1_bit;
    TFT_RST : sbit  at LATC1_bit;
    TFT_WR_Direction : sbit  at TRISD4_bit;
    TFT_WR : sbit  at LATD4_bit;
// End TFT module connections


var Xcoord, Ycoord : word;

procedure PMPWaitBusy();
begin
  while(PMMODE.BUSY = 1) do ;
end;


procedure Set_Index(index : byte);
begin
  TFT_RS := 0;
  PMDIN := index;
  PMPWaitBusy();
end;

procedure Write_Command(cmd : byte);
begin
  TFT_RS := 1;
  PMDIN := cmd;
  PMPWaitBusy();
end;

procedure Write_Data(_data : word);
begin
  TFT_RS := 1;
  PMDIN := _data;
  PMPWaitBusy();
end;


procedure InitializeTouchPanel(); // static
begin
  TFT_Set_Active(@Set_Index, @Write_Command, @Write_Data);
  TFT_Init_SSD1963(480, 272);
  TFT_Set_DBC_SSD1963(255);
end;

procedure Calibrate();
  begin
    TFT_Fill_Screen(CL_BLACK);
    TFT_Set_Font(@TFT_defaultFont, CL_WHITE, FO_HORIZONTAL);
    TFT_Write_Text('Touch points on the screen as they', 125, 121);
    TFT_Write_Text('appear to calibrate touchscreen.', 135, 151);
    STMPE610_ClearInterruptFlagsAndFIFO();
    TFT_Set_Brush(1, CL_WHITE, 0, 0, 0, 0);
    TFT_Circle(0, 0, 3);
    STMPE610_CalibratePoint(STMPE610_FIRST_CORNER);
    Delay_ms(500);
    TFT_Set_Brush(1, CL_BLACK, 0, 0, 0, 0);
    TFT_Circle(0, 0, 3);
    STMPE610_ClearInterruptFlagsAndFIFO();
    TFT_Set_Brush(1, CL_WHITE, 0, 0, 0, 0);
    TFT_Circle(0, TFT_DISP_HEIGHT-1, 3);
    STMPE610_CalibratePoint(STMPE610_SECOND_CORNER);
    Delay_ms(500);
    TFT_Set_Brush(1, CL_BLACK, 0, 0, 0, 0);
    TFT_Circle(0, TFT_DISP_HEIGHT-1, 3);
    STMPE610_ClearInterruptFlagsAndFIFO();
    TFT_Set_Brush(1, CL_WHITE, 0, 0, 0, 0);
    TFT_Circle(TFT_DISP_WIDTH-1, TFT_DISP_HEIGHT-1, 3);
    STMPE610_CalibratePoint(STMPE610_THIRD_CORNER);
    Delay_ms(500);
    TFT_Set_Brush(1, CL_BLACK, 0, 0, 0, 0);
    TFT_Circle(TFT_DISP_WIDTH-1, TFT_DISP_HEIGHT-1, 3);
    STMPE610_ClearInterruptFlagsAndFIFO();
    TFT_Set_Brush(1, CL_WHITE, 0, 0, 0, 0);
    TFT_Circle(TFT_DISP_WIDTH-1, 0, 3);
    STMPE610_CalibratePoint(STMPE610_FOURTH_CORNER);
    TFT_Set_Brush(1, CL_BLACK, 0, 0, 0, 0);
    TFT_Circle(TFT_DISP_WIDTH-1, 0, 3);
    Delay_ms(500);
  end;


procedure Check_TP();
begin
  if (STMPE610_PressDetect()) then
  begin
    if (STMPE610_GetLastCoordinates(@Xcoord, @Ycoord) = 0) then
    begin
      DynTFTMCU_OldXMouse := DynTFTMCU_XMouse;
      DynTFTMCU_OldYMouse := DynTFTMCU_YMouse;
      DynTFTMCU_XMouse := Xcoord;
      DynTFTMCU_YMouse := Ycoord;
      DynTFTReceivedMouseDown := True;
    end;
  end
  else
  begin
    DynTFTMCU_XMouse := Xcoord;
    DynTFTMCU_YMouse := Ycoord;
    DynTFTReceivedMouseUp := True;
  end;
end;

procedure Init_MCU();
begin
  AD1PCFG := 0xFFFF;
  JTAGEN_bit := 0;
  // If bus is busy wait SDA high before initializing I2C module
  TRISA2_bit := 0;
  TRISA3_bit := 1;
  LATA2_bit := 1;
  while (PORTA.B3 = 0) do
    begin
      LATA2_bit := 0;
      Delay_us(10);
      LATA2_bit := 1;
      Delay_us(10);
    end;

  I2C2_Init(100000);
  // PMP setup
  PMMODE := 0;
  // PMAEN: Parallel Master Port Address Enable Register
  PMAEN  := 0;  // pins used as normal I/O
  PMCON  := 0;  // WRSP: Write Strobe Polarity bit
  PMMODE := 0;
  PMAEN := 0;
  PMCON := 0;
  PMMODE := 0x0604;
  PMCON := 0x8300;
  TFT_Set_Default_Mode();
  STMPE610_SetDefaultMode();
  TFT_Set_MM_Plus();
end;


function STMPE610_Config()  : byte;
begin
    STMPE610_SetI2CAddress(STMPE610_I2C_ADDR1);
    if (STMPE610_IsOperational() <> 0) then
    begin
        Result := STMPE610_IO_NOT_OPERATIONAL;
        Exit;
    end;

    STMPE610_Reset();
    STMPE610_Module(STMPE610_MODULE_TS or STMPE610_MODULE_ADC, STMPE610_ENABLE);
    STMPE610_AlternateFunction(STMPE610_GPIO_PIN1, STMPE610_ENABLE);
    STMPE610_SetGPIOPin(STMPE610_GPIO_PIN1, 0);   // IN1 to "0" -> I2C communication
    STMPE610_SetSize(480,272);
    STMPE610_Module(STMPE610_MODULE_TS or STMPE610_MODULE_ADC, STMPE610_ENABLE);
    STMPE610_EnableInterrupt(0, STMPE610_ENABLE);
    STMPE610_ConfigureInterrupt(STMPE610_INT_POLARITY_ACTIVE_HIGH or STMPE610_INT_TYPE_EDGE or STMPE610_INT_ENABLE_ALL);
    STMPE610_SetADC(STMPE610_ADC_CTRL1_SAMPLETIME_56 or STMPE610_ADC_CTRL1_ADC_12BIT or STMPE610_ADC_CTRL1_INT_REFERENCE);
    Delay_10ms(); Delay_10ms();
    STMPE610_SetADCClock(STMPE610_ADC_CTRL2_3250_kHZ);
    STMPE610_AlternateFunction(STMPE610_GPIO_PIN4 or STMPE610_GPIO_PIN5 or STMPE610_GPIO_PIN6 or STMPE610_GPIO_PIN7, STMPE610_DISABLE);
    STMPE610_ConfigureTSC(STMPE610_TSC_CFG_AVE_CTRL_4S, STMPE610_TSC_CFG_TOUCH_DET_DELAY_500uS, STMPE610_TSC_CFG_TOUCH_SETTLING_1mS);
    STMPE610_SetFIFOThreshold(1);
    STMPE610_ResetFIFO();
    STMPE610_TSIDrive(STMPE610_TSC_I_DRIVE_20mA);
    STMPE610_TSControl(STMPE610_TSC_CTRL_TRACK0 or STMPE610_TSC_CTRL_ACQU_XYZ or STMPE610_TSC_CTRL_ENABLE);
    STMPE610_ZDataFraction(STMPE610_FRACP4_WHOLP4);
    STMPE610_SetTouchPressureThreshold(70);
    STMPE610_ClearInterrupts();
    STMPE610_WriteReg(STMPE610_INT_CTRL_REG, 0x01);
    Result := STMPE610_OK;
end;


procedure MainLoopIteration;
begin
  Check_TP;
  DynTFT_GUI_LoopIteration;
end;


procedure HandleMessageBox(AMessageBox: PDynTFTMessageBox);
begin
  repeat
    MainLoopIteration;
  until AMessageBox^.Done;
end;


var 
  TPConstsStruct: TTPConstants;
  AText: string[10];

begin
  MM_Init;
  
  Init_MCU();
  InitializeTouchPanel();
  
  if (STMPE610_Config() = STMPE610_OK) then
  begin
  end
  else
    while (TRUE) do ;
              {
  Delay_ms(1000);
  TFT_Fill_Screen(0);
  Calibrate();

  STMPE610_GetCalibrationConsts(@TPConstsStruct);

  TFT_Fill_Screen(0);
                 }
                 
  TPConstsStruct.X_Min := 192;
  TPConstsStruct.X_Max := 3909;
  TPConstsStruct.Y_Min := 218;
  TPConstsStruct.Y_Max := 3846;
  TPConstsStruct.Rotate := 0;
  STMPE610_SetCalibrationConsts(@TPConstsStruct);
                 
  TFT_Set_Brush(1, CL_WHITE, 0, 0, 0, 0);
  TFT_Rectangle(0, 0, 480, 272);
  
  DynTFT_GUI_Start;
  DynTFTMessageBoxMainLoopHandler := @HandleMessageBox; //use this if you want modal MessageBox
              {
  IntToStr(TPConstsStruct.X_Min, AText);   TFT_Write_Text(AText, 330, 10);
  IntToStr(TPConstsStruct.X_Max, AText);   TFT_Write_Text(AText, 330, 30);
  IntToStr(TPConstsStruct.Y_Min, AText);   TFT_Write_Text(AText, 330, 50);
  IntToStr(TPConstsStruct.Y_Max, AText);   TFT_Write_Text(AText, 330, 70);
  IntToStr(TPConstsStruct.Rotate, AText);  TFT_Write_Text(AText, 330, 90);
                   }

  repeat
    MainLoopIteration;
  until False;
end.